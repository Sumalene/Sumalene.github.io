---
layout: single
title: "[AI]权重机制与变形金刚"
categories: [Web, AI]
last_modified_at: 2023-07-17
excerpt: "从s-Attention机制到bert"
header: 
  teaser: https://act-upload.mihoyo.com/bh3-wiki/2023/07/15/75216984/310ffe1e3e9c4be33fa19b1c256c2d22_4224300868418670346.png
---

## encoder-decoder模型

该模型由两个RNN（循环神经网络）组合而成。在这个模型中，编码（encoder）是指将输入序列转化为一个固定长度的向量表示的过程。传统的RNN的输出是分开的，即每个时间步都有一个输出，而编码则是将这些输出整合为一个向量表示。
编码器的结构通常是一个循环神经网络，它通过逐个时间步处理输入序列，并在每个时间步产生一个隐藏状态。这些隐藏状态会被传递到下一个时间步，同时也会用于输出。编码器的最后一个隐藏状态通常被认为是整个输入序列的表示，也就是编码。
解码（decoder）则是另一个RNN，它接收编码器的输出作为输入，并根据需要生成目标序列。解码器在每个时间步生成一个输出，并将其隐藏状态传递到下一个时间步。这个过程会重复，直到生成完整的目标序列。
因此，encoder-decoder模型使用编码器将输入序列转化为一个固定长度的向量表示，然后使用解码器根据这个向量生成目标序列。这种结构在机器翻译、语音识别等任务中被广泛应用。

以传统翻译任务为例：
![img](https://github.com/Sumalene/Sumalene.github.io/assets/124686994/c6f04750-3d77-45a8-8d22-b4205e5262cf)

RNN可以用记忆链考虑前置序列的重要性，传统的RNN存在梯度消失和梯度爆炸等问题，这限制了其对长序列的建模能力。 
LSTM则加入门控机制，能够选择性地记忆和遗忘输入数据中的信息，从而更好地处理长期依赖关系。问题同上
在翻译任务中，Encoder-Decoder模型结合了编码器和解码器两个部分。编码器负责将源语言句子编码成一个固定长度的向量表示，而解码器则根据这个向量生成目标语言句子。编码器和解码器都可以使用RNN或LSTM作为基本的神经网络结构。但是只有一个相同长度的编码c，显然降低了翻译精度。

## attention机制

![image](https://github.com/Sumalene/Sumalene.github.io/assets/124686994/e324b66d-60b5-4b98-8ad1-95569ad0adf0)
每个时间对应不同的c，连线代表了所有时刻ti对cij的影响权重（注意力分布attention）通过神经网络训练得到最好的权重矩阵。
- 同时注意到该想法的实践下，GPU并行效率低，而模型本身已经对输入token打了分，即：rnn本身的顺序没有什么作用了

于是有了：自注意力机制（Self-attention Mechanism）一种用于处理序列数据的重要技术，它在自然语言处理领域具有广泛的应用。通过将输入序列中的各个位置之间的关系进行建模，自注意力机制可以有效地捕捉到序列中不同位置的依赖关系。


自注意力机制最早出现在Transformer模型中，Transformer是一种基于注意力机制的模型架构，被广泛应用于机器翻译任务。在Transformer中，自注意力机制被用于计算输入序列中每个位置的权重，这些权重表示每个位置与其他位置的关联程度。通过将每个位置与所有其他位置进行比较，自注意力机制可以确定每个位置对于其他位置的重要性。

自注意力机制的优势在于，它能够同时考虑到输入序列中的全局信息和局部信息，从而更好地捕捉到序列中的内部结构和语义关联。此外，自注意力机制还具有并行计算的特点，使得模型训练的速度更快。

具体而言，自注意力机制通过计算查询-键值对中的注意力权重来实现。首先，通过对输入序列进行线性映射，得到查询（Q）、键（K）和值（V）矩阵。然后，通过计算Q与K的点积并进行缩放，再经过softmax函数得到注意力分数。最后，将注意力分数与V相乘并求和得到输出。

![image](https://github.com/Sumalene/Sumalene.github.io/assets/124686994/9099920f-dd2e-46b0-a160-ff0483bbe969)

前馈网络，重复做一下：
![image](https://github.com/Sumalene/Sumalene.github.io/assets/124686994/bd4d12fc-0e56-4426-bbdc-b0ea97e6f882)

通过加权求和感知重要的部分，理解上下文。专注做事，只有...

---

## Transformer网络
![image](https://github.com/Sumalene/Sumalene.github.io/assets/124686994/0dadb21c-638b-4768-b74f-fddaea1e10c9)
其中每个encoder都包含自注意力机制和前馈网络，每一次前馈都是根据权重变一次形状。

decoder中，注意力和前馈之间多一层编解码权重，即解码时考虑编码的上下文全局
![image](https://github.com/Sumalene/Sumalene.github.io/assets/124686994/e7455332-7a1c-4e9b-8c32-157f9676812f)
而每一个自注意力机制层又可以拆解（多头注意力），也就是模块化的拼装

算法向量化单词，加入位置信息，统一编码长度
  ![image](https://github.com/Sumalene/Sumalene.github.io/assets/124686994/beea2785-475c-474e-bcb1-f47fa5893835)
通过对输入序列进行线性映射（刚刚那句话），得到查询（Q）、键（K）和值（V）矩阵（词+序列向量整体乘以训练好的kqv分量）。然后，通过计算Q与K的点积并进行缩放，再经过softmax函数得到注意力分数（归一化过滤不相干的单词）。最后，将注意力分数与V相乘并求和，输出矩阵Z，与开始相比，维度不变，但掺入了上下文信息；多头注意下，采用不同的qkv，消除初值的影响。

结合刚刚的相同（所谓拼装）内容，细说的话：多头注意力机制中的不同注意力头使用不同的Q（查询）、K（键）和V（值）矩阵来计算注意力权重。在传统的注意力机制中，这些矩阵是相同的，而在多头注意力中，每个注意力头都有自己独立的Q、K和V矩阵。 
 具体来说，给定一个输入序列，我们使用线性变换将其转换为三个不同的表示：Q、K和V。Q矩阵用于计算查询向量，K矩阵用于计算键向量，V矩阵用于计算值向量。然后，通过计算查询向量和键向量之间的相似度，得到注意力权重。最后，将注意力权重与值向量进行加权求和，得到最终的注意力表示。 
 通过使用不同的QKV矩阵，每个注意力头可以关注输入序列的不同部分，从而捕捉到不同的特征和对齐关系。这样，模型可以同时关注多个不同的语义和结构信息，提高建模能力。 

- 总结：1.输入词向量化 2.矩阵运算  3.注意力得到权重kqv 3.加权求和输出z

翻译输出的终点：线性层和softmax层

---
线性层和softmax层是Transformer模型中常用的两种层。它们通常用于模型的最后一层，用于将模型的输出向量转化为概率分布。 
线性层（Linear Layer）是一个全连接层，它将输入向量映射到一个新的向量空间。在Transformer模型中，线性层通常用于将解码器堆栈的输出向量映射为词汇表中每个单词的得分。这些得分表示了模型认为每个单词是输出序列中的下一个单词的概率。 
是一个很长的一维向量，包含所有的单词
 
softmax层是一个激活函数，它将线性层的输出转化为概率分布(最后的归一化)。它通过对线性层的输出进行指数化和归一化，将每个得分转化为一个概率值。在Transformer模型中，softmax层通常用于将线性层的输出转化为生成下一个单词的概率分布。

---

## GNN和VAE之后总结，先认识一下术语：

 1. 欧几里得空间：欧几里得空间是我们熟悉的传统几何空间，其中包含了平面、立体等几何形状。在AI中，我们可以将欧几里得空间看作是特征之间具有固定距离和关系的空间。例如，在图像处理中，每个像素的位置可以表示为二维欧几里得空间中的坐标。 
 2. 非欧几里得空间：非欧几里得空间是一种特殊的空间，其中距离和关系不是固定的。在AI中，非欧几里得空间通常用来表示具有复杂关系的数据，例如社交网络、知识图谱等。这些数据无法简单地用欧几里得空间中的坐标表示，而是需要使用图来表示节点之间的连接关系。 
 
 举个例子来说明，假设我们要分析一个社交网络的数据。在欧几里得空间中，我们只能使用坐标来表示每个人的位置，但无法捕捉到人与人之间的关系。而在非欧几里得空间中，我们可以使用图来表示每个人作为节点，边表示人与人之间的关系。这样，我们可以利用图神经网络来分析人与人之间的连接、社群结构等信息。 
 总结起来，欧几里得空间是传统的几何空间，用于表示具有固定距离和关系的数据。非欧几里得空间是一种特殊的空间，用于表示具有复杂关系的数据，通常使用图来表示节点之间的连接关系。通过图神经网络，我们可以更好地处理非欧几里得空间中的数据。 自觉去补离散数学-图论

---
## Bert & GPT 大规模预训练军团

BERT（Bidirectional Encoder Representations from Transformers）将Transformer的编码器独立出来，并进行了改进。通过大规模的无监督预训练来学习通用的语言表示。BERT的编码器部分由多层Transformer组成，每层都包含自注意力机制和前馈神经网络。通过预训练，BERT能够学习到丰富的语言知识，包括词义、句法和语境等。 
 在预训练完成后，BERT可以被微调用于各种下游任务，如文本分类、命名实体识别等。在微调过程中，BERT的编码器可以接受输入序列，并生成对应的上下文相关的表示。这些表示可以用于下游任务的特征提取，从而提升模型性能。 这种独立的编码器可以被用于各种下游任务，使得模型在处理自然语言任务时具有更好的性能和泛化能力。 


GPT（Generative Pre-trained Transformer）是一种基于Transformer的神经网络模型，它将Transformer的解码器组装起来，用于生成自然语言文本。在GPT中，解码器由多层Transformer组成，每层都包含自注意力机制和前馈神经网络。
通过预训练，GPT可以学习到丰富的语言知识，从而生成高质量的自然语言文本。在生成文本时，GPT接受一个输入序列，并根据该序列生成下一个单词或字符，从而逐步生成完整的文本。
